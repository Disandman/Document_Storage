# Ревью от 25.09.2021

1. Маршруты для API

Не совсем ошибка, просто такое вот замечание.

Вместо

```php
'rules' => [
    [
        'class' => 'yii\rest\UrlRule',
        'controller' => ['user' => 'api_v1/user'],
        'prefix' => 'api/v1',
        'pluralize' => false,
    ],
    [
        'class' => 'yii\rest\UrlRule',
        'controller' => ['upload' => 'api_v1/upload'],
        'prefix' => 'api/v1',
        'pluralize' => false,
    ],
],
```

Можно было просто сделать так

```php
'rules' => [
    [
        'class' => 'yii\rest\UrlRule',
        'controller' => [
            'user' => 'api_v1/user',
            'upload' => 'api_v1/upload'
        ],
        'prefix' => 'api/v1',
        'pluralize' => false,
    ],
],
```

Оба вариант рабочие, но предпочтительнее всё же второй.

2. Уникальные имена

Увидела, что добавил uniqid и вынес в метод, молодец) Только вот одно лечим, другое калечим))

Твоя функция `getUniqueName` при каждом обращении будет создавать новое уникальное имя. Отсюда вытекает 2 проблемы:

- Неоднозначность именования. Или надо немного модифицировать код, чтобы это действительно было get, или надо его переименовать в `generateUniqueName`.

- Вот с этом коде мы получаем в базе одно название, а на диске другое:

```php
$model->size = $model->getFileSize();
$model->unique_name = $model->getUniqueName(); // Первое уникальное имя, оно пойдет в базу
$model->name = $model->file->name;
$model->date = date("Y-m-d");
$transaction = $model::getDb()->beginTransaction(); 
if($model->save()) {
    if($model->file->saveAs($model::getPathToFile($model->getUniqueName()))) { // Второе уникальное имя для ТОГО ЖЕ файла, с ним будет запись на диск
        $transaction->commit();
        $this->response->setStatusCode(201);
        return $model;
    } else {
        $transaction->rollBack(); 
        throw new ServerErrorHttpException(Yii::t('app', 'Failed to save file on disk'));
    }
}
```

Как результат - получается каша. Что я бы предложила сделать?

В модели `Upload` при обращении к методу `getUniqueName` мы проверяем, есть ли данные в атрибуте `unique_name`. 
Если есть - отдаем значение `unique_name`, если нет - генерируем уникальное имя, кладем его в `unique_name` и опять же возвращаем `unique_name`.

```php

private function generateUniqueName()
{
    return uniqid() . '.' . $this->file->getExtension();
}

public function getUniqueName() 
{
    if(!$this->unique_name) {
        $this->unique_name = $this->generateUniqueName();
    }

    return $this->unique_name;
}

```

Т.о. функции одназначно определены, извне никто лишний раз не дергает генератор и имя не меняется при обращении.

Только надо учесть, что при загрузке нового документа вместо старого, возможно придется принудительно чистить `unique_name`. Или можно добавить для таких случаев еще одну функцию:


```php
public function regenerateUniqueName() 
{
    $this->unique_name = $this->generateUniqueName();

    return $this->unique_name;
}
```

3. Метод удаления файлов (п. 6 прошлого ревью)

Увидела корректировки пункта 6. Однако id всё еще посылается через get. В данном случае это не критично, но вообще операции на удаление
лучше тоже через POST слать, а на стороне сервера при обращении по get, посылать NotImplemented.

4.  Немного про запросы

Как должен работать этот кусочек кода?))

```php
$query = UploadModel::find()
            ->where(['type' => 0 || 1]);
```

Я так подразумеваю, это что-то типа:

_Найти все модели с типом 0 или 1_

Только по коду это звучит так:

_Найти все модели с типом true_ (при построении запроса true скорее всего заменится на 1)

Всё потому что `||` это логический оператор, который возвращает true (1), если хотя бы одно условие истина (1), или false (0) в противном случае.

Так что если хочется в выборку взять и тот тип и тот, то надо писать так:

```php
$query = UploadModel::find()
            ->where([
                'OR',
                ['=', 'type', 0],
                ['=', 'type', 1],
            ]);
```

И ещё желатьно вместо 0 и 1 использовать константы из класса `Upload`.

5. Пароль в API user

- Я бы, пожалуй, запретила менять пароль на методе Update. Это чисто субъективщина, не ошибка.
- Для пароля лучше завести свойство password в модели, которая работает с API. Не очень очевидно, что пароль надо запихнуть
в поле `password_hash`. 

```php
$password = $this->request->getBodyParam('password_hash');
```

А `password_hash` наоборот скрыть и сделать нередактируемым извне. Пусть меняется строго при смене пароля самой системой.

6. Пожелания)))

В остальном всё проверила, всё работает, мне нравится.

Чего не хватает API для полного счастья? А не хватает возможности генерирования токенов. Т.е. как я поняла, сейчас у тебя приложение генерирует токен 1 раз при регистрации и кладет его в базу (я же верно поняла?). А дальше токен бессмертный.

С т.з. безопасности это не хорошо. Токены должны иметь время жизни. Да, клиенту тогда придется, возможно, сделать 2 запроса к апи вместо одного, но оно того стоит.

**Принцип работы с обновляемым токеном:**

- Пользователь посылает запрос к, н-р, `/api/v1/auth`. При отсылаются логин и пароль для авторизации (можно через Basic Auth).
- Приложение проверяет, что пользователь есть в системе и активен, генерирует ему новый токен и отдает в ответ. У токена есть время жизни (н-р, 3 часа).
- Пользователь с помощью токена делает запросы к остальному API.
- Приложение ищет активный токен в базе токенов, если такой найден, находит пользователя. Если токен не найден (истек), то выбрасывается исключение, что wrong credentials.

Вот если ещё это сделаешь, приложение можно больше не мучить)




<p align="center">
    <a href="https://github.com/yiisoft" target="_blank">
        <img src="https://avatars0.githubusercontent.com/u/993323" height="100px">
    </a>
    <h1 align="center">Приложение для хранения документов на PHP (https://projectsil.ru)</h1>
    <h3 align="center">Необходимо разработать приложение, которое позволит организовывать хранение документов с различными разрешениями.</h3>
</p>


Требования к функционалу:
-------------------

○ Документы должны делиться на публичные (доступны «гостям»), условно-приватные (доступны авторизированным пользователям) и приватные (доступны только загрузившему пользователю).
</br>
○ Необходимо предусмотреть функционал авторизации и регистрации.
</br>
○ Необходимо вести некоторую статистику:
</br>
   − Сколько документов загружено в день / месяц / год
</br>
   − Соотношение публичных, условно-приватных и приватных документов за выбранный интервал времени.
</br>
○ Бекэнд должен быть написан на Yii2

Роли в системе:
-------------------

○ Гость – неавторизованный посетитель системы. Может просматривать публичные документы.
</br>
○ Необходимо предусмотреть функционал авторизации и регистрации.
</br>
○ Пользователь – посетитель, имеющий учетную запись в системе и авторизованный в ней. Может загружать свои документы, настраивать их приватность; просматривать публичные, условно-приватные и свои документы.
</br>
○ Администратор – пользователь, имеющий права на просмотр всех файлов и на управление другими пользователями.
INSTALLATION

Дополнительно (по желанию):
-------------------
○ Написание простых unit или acceptance тестов.
